//process.exit(0) // ignore the template in tests....
const path = require('path');
const {argParser} = require('./utils');
const defaultPathAdaptor = path.join('..',path.sep, '..');
const {OPENDSU_PROCESS_PROP} = require('./constants');
const {setOpenDSU} = require('./jest-opendsu-client');

const DOMAIN_CONFIG = {
    anchoring: {
        type: "FS",
        option: {
            enableBricksLedger: false,
        },
        commands: {
            addAnchor: "anchor",
        },
    },
    enable: ["mq"],
};

const getBDNSConfig = function(name, domains){
    if (!domains)
        domains = [{
            name: name,
            config: DOMAIN_CONFIG
        }];
    return {
        maxTries: 10,
        domains: domains.map((d, i) =>
            ({
                name: name[i],
                config: DOMAIN_CONFIG,
            })
        ),
    }
}

const defaultOps = {
    timeout: 1000,
    fakeServer: true,
    useCallback: true
}

/**
 * Utility class to perform tests with openDSU
 *
 * @param {string} name defines the name of the test
 * @param {string} domain defines the domain
 * @param {{}} defaultOptions configuration for the test {@link defaultOps}
 * @param {{}} bdnsConfig bdns configuration {@link getBDNSConfig} undefined could be used on this arg
 * @param {string} pathAdaptor relative path to the privatesky testRuntime.js. if used as a node module "../../../../" should be used.
 *
 *
 * @class OpenDSUTestRunner
 */

class OpenDSUTestRunner {
    name;
    options;
    bdnsConfig;

    opendsu;
    dc;
    assert;
    tir;

    jestCallback;

    constructor(name, domain, defaultOptions, bdnsConfig, pathAdaptor, pskConfigLocation, jestCallback){
        process.env.NO_LOGS = true;
        process.env.PSK_CONFIG_LOCATION = typeof pskConfigLocation === 'string' ? pskConfigLocation : process.cwd();

        this.name = name;
        this.options = argParser(Object.assign({}, defaultOps, defaultOptions), process.argv);
        this.bdnsConfig = bdnsConfig || getBDNSConfig(domain || "default");
        this.jestCallback = jestCallback;

        setOpenDSU();
        if (globalThis.opendsu){
            this.tir = globalThis.tir
            this.opendsu = globalThis.opendsu;
        } else {
            const test_bundles_path = path.join(pathAdaptor, 'privatesky/psknode/bundles', 'testsRuntime.js');
            require(test_bundles_path);
            this.dc = require("double-check");
            this.assert = this.dc.assert;
            this.opendsu = require('opendsu');
            this.tir = require(path.join(pathAdaptor, "privatesky/psknode/tests/util/tir"));
        }
    }

    instantiateWallet(walletName, domain, callback){
        throw new Error("Not implemented");
    }

    cloneExternalVolume(callback){
        throw new Error("Not implemented");
    }

    cloneCurrentDeploy(callback){
        throw new Error("Not implemented");
    }

    run(test){
        const self = this;

        const testFinishCallback = function(callback){
            console.log(`Test ${self.name} finished successfully`);
            if (callback)
                return callback();
            if (!self.jestCallback)
                setTimeout(() => {
                    process.exit(0);
                }, 1000)
        }

        const launchTest = function(callback){

            if (self.jestCallback){
                const oldCb = callback;
                callback = (...args) => {
                    oldCb(...args);
                    self.jestCallback()
                }
            }

            const testRunner = function(callback){
                test((err) => {
                    if (err){
                        console.error(err);
                        process.exit(1)
                    }
                    testFinishCallback(callback);
                });
            }

            const runWithFakeServer = function(callback){
                self.dc.createTestFolder(self.name.split(' ').join('-'), async (err, folder) => {
                    await self.tir.launchConfigurableApiHubTestNodeAsync(Object.assign({}, self.bdnsConfig, {
                        storageFolder: folder
                    }));

                    if (!callback)
                        self.assert.begin(`Running test ${self.name}`, undefined, self.options.timeout);
                    testRunner(callback);
                });
            }

            if (self.options.fakeServer)
                return runWithFakeServer(callback);

            if (!callback)
                self.assert.begin(`Running test ${self.name}`, undefined, self.options.timeout);
            testRunner(callback);
        }

        if (!self.options.useCallback)
            return launchTest();
        self.assert.callback(self.name, (testFinished) => {
            launchTest(testFinished);
        }, self.options.timeout)
    }
}

module.exports = {
    OpenDSUTestRunner,
    defaultOps,
    defaultPathAdaptor,
    getBDNSConfig,
    DOMAIN_CONFIG
}